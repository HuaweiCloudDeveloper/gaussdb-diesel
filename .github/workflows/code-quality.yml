name: Code Quality

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run weekly code quality checks on Sundays at 3 AM UTC
    - cron: '0 3 * * 0'

env:
  CARGO_TERM_COLOR: always

jobs:
  # ‰ª£Á†ÅË¶ÜÁõñÁéá
  code-coverage:
    name: Code Coverage
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: Gaussdb@123
          POSTGRES_DB: diesel_test
          POSTGRES_USER: gaussdb
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U gaussdb -d diesel_test"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: llvm-tools-preview

    - name: Install cargo-llvm-cov
      run: cargo install cargo-llvm-cov

    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-coverage-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-coverage-cargo-

    - name: Generate code coverage
      env:
        GAUSSDB_TEST_URL: "host=localhost port=5432 user=gaussdb password=Gaussdb@123 dbname=diesel_test"
      run: |
        echo "Generating code coverage report..."
        cargo llvm-cov --all-features --workspace --lcov --output-path lcov.info
        cargo llvm-cov --all-features --workspace --html --output-dir coverage_html
        cargo llvm-cov --all-features --workspace --json --output-path coverage.json

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: lcov.info
        fail_ci_if_error: false
        verbose: true

    - name: Generate coverage report
      run: |
        echo "# Code Coverage Report" > coverage_report.md
        echo "Generated at: $(date -u)" >> coverage_report.md
        echo "" >> coverage_report.md
        
        # Extract coverage percentage from JSON
        COVERAGE=$(jq -r '.data[0].totals.lines.percent' coverage.json 2>/dev/null || echo "N/A")
        echo "## üìä Coverage Summary" >> coverage_report.md
        echo "- **Overall Coverage**: ${COVERAGE}%" >> coverage_report.md
        echo "- **Report Format**: LCOV, HTML, JSON" >> coverage_report.md
        echo "- **Timestamp**: $(date -u)" >> coverage_report.md
        echo "" >> coverage_report.md
        
        echo "## üéØ Coverage Goals" >> coverage_report.md
        if [ "$COVERAGE" != "N/A" ]; then
          if (( $(echo "$COVERAGE >= 80" | bc -l) )); then
            echo "‚úÖ Coverage meets target (‚â•80%)" >> coverage_report.md
          else
            echo "‚ö†Ô∏è Coverage below target (<80%)" >> coverage_report.md
          fi
        else
          echo "‚ùì Coverage percentage could not be determined" >> coverage_report.md
        fi

    - name: Upload coverage artifacts
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: |
          coverage_report.md
          lcov.info
          coverage.json
          coverage_html/

  # ‰ª£Á†ÅÂ§çÊùÇÂ∫¶ÂàÜÊûê
  complexity-analysis:
    name: Code Complexity Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Install tokei (for code statistics)
      run: cargo install tokei

    - name: Install scc (for complexity analysis)
      run: |
        wget https://github.com/boyter/scc/releases/download/v3.1.0/scc-3.1.0-x86_64-unknown-linux.zip
        unzip scc-3.1.0-x86_64-unknown-linux.zip
        chmod +x scc
        sudo mv scc /usr/local/bin/

    - name: Generate code statistics
      run: |
        echo "Generating code statistics..."
        tokei --output json > code_stats.json
        tokei
        
        echo "Generating complexity analysis..."
        scc --format json src/ > complexity.json
        scc src/

    - name: Generate complexity report
      run: |
        echo "# Code Complexity Report" > complexity_report.md
        echo "Generated at: $(date -u)" >> complexity_report.md
        echo "" >> complexity_report.md
        
        echo "## üìä Code Statistics" >> complexity_report.md
        if [ -f code_stats.json ]; then
          RUST_LINES=$(jq -r '.Rust.code' code_stats.json 2>/dev/null || echo "N/A")
          RUST_COMMENTS=$(jq -r '.Rust.comments' code_stats.json 2>/dev/null || echo "N/A")
          RUST_FILES=$(jq -r '.Rust.reports | length' code_stats.json 2>/dev/null || echo "N/A")
          
          echo "- **Rust Files**: $RUST_FILES" >> complexity_report.md
          echo "- **Lines of Code**: $RUST_LINES" >> complexity_report.md
          echo "- **Comment Lines**: $RUST_COMMENTS" >> complexity_report.md
          
          if [ "$RUST_LINES" != "N/A" ] && [ "$RUST_COMMENTS" != "N/A" ]; then
            COMMENT_RATIO=$(echo "scale=2; $RUST_COMMENTS * 100 / $RUST_LINES" | bc -l 2>/dev/null || echo "N/A")
            echo "- **Comment Ratio**: ${COMMENT_RATIO}%" >> complexity_report.md
          fi
        fi
        echo "" >> complexity_report.md
        
        echo "## üîç Complexity Analysis" >> complexity_report.md
        if [ -f complexity.json ]; then
          AVG_COMPLEXITY=$(jq -r '.[0].AverageComplexity' complexity.json 2>/dev/null || echo "N/A")
          MAX_COMPLEXITY=$(jq -r '.[0].MaxComplexity' complexity.json 2>/dev/null || echo "N/A")
          
          echo "- **Average Complexity**: $AVG_COMPLEXITY" >> complexity_report.md
          echo "- **Maximum Complexity**: $MAX_COMPLEXITY" >> complexity_report.md
          
          if [ "$AVG_COMPLEXITY" != "N/A" ]; then
            if (( $(echo "$AVG_COMPLEXITY <= 10" | bc -l) )); then
              echo "- **Complexity Status**: ‚úÖ Good (‚â§10)" >> complexity_report.md
            else
              echo "- **Complexity Status**: ‚ö†Ô∏è High (>10)" >> complexity_report.md
            fi
          fi
        fi

    - name: Upload complexity report
      uses: actions/upload-artifact@v4
      with:
        name: complexity-report
        path: |
          complexity_report.md
          code_stats.json
          complexity.json

  # ‰ª£Á†ÅË¥®ÈáèÊ£ÄÊü•
  quality-checks:
    name: Quality Checks
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy

    - name: Cache cargo registry
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-quality-cargo-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-quality-cargo-

    - name: Run rustfmt check
      run: |
        echo "Checking code formatting..."
        cargo fmt --all -- --check > fmt_report.txt 2>&1 || echo "Formatting issues found"

    - name: Run clippy analysis
      run: |
        echo "Running clippy analysis..."
        cargo clippy --all-targets --all-features --message-format=json -- -D warnings > clippy_report.json 2>&1 || echo "Clippy issues found"
        cargo clippy --all-targets --all-features -- -D warnings

    - name: Check for TODO/FIXME comments
      run: |
        echo "Checking for TODO/FIXME comments..."
        grep -rn "TODO\|FIXME\|XXX\|HACK" src/ > todo_report.txt || echo "No TODO/FIXME comments found"

    - name: Generate quality report
      run: |
        echo "# Code Quality Report" > quality_report.md
        echo "Generated at: $(date -u)" >> quality_report.md
        echo "" >> quality_report.md
        
        echo "## üé® Formatting" >> quality_report.md
        if [ -s fmt_report.txt ]; then
          echo "‚ö†Ô∏è Formatting issues found:" >> quality_report.md
          echo '```' >> quality_report.md
          cat fmt_report.txt >> quality_report.md
          echo '```' >> quality_report.md
        else
          echo "‚úÖ Code is properly formatted" >> quality_report.md
        fi
        echo "" >> quality_report.md
        
        echo "## üìé Clippy Analysis" >> quality_report.md
        if [ -s clippy_report.json ]; then
          CLIPPY_WARNINGS=$(jq -r 'select(.reason == "compiler-message") | .message.level' clippy_report.json 2>/dev/null | grep -c "warning" || echo "0")
          CLIPPY_ERRORS=$(jq -r 'select(.reason == "compiler-message") | .message.level' clippy_report.json 2>/dev/null | grep -c "error" || echo "0")
          
          echo "- **Warnings**: $CLIPPY_WARNINGS" >> quality_report.md
          echo "- **Errors**: $CLIPPY_ERRORS" >> quality_report.md
          
          if [ "$CLIPPY_ERRORS" -eq 0 ] && [ "$CLIPPY_WARNINGS" -eq 0 ]; then
            echo "- **Status**: ‚úÖ No issues found" >> quality_report.md
          else
            echo "- **Status**: ‚ö†Ô∏è Issues found" >> quality_report.md
          fi
        else
          echo "‚úÖ No clippy issues found" >> quality_report.md
        fi
        echo "" >> quality_report.md
        
        echo "## üìù TODO/FIXME Comments" >> quality_report.md
        if [ -s todo_report.txt ]; then
          TODO_COUNT=$(wc -l < todo_report.txt)
          echo "Found $TODO_COUNT TODO/FIXME comments:" >> quality_report.md
          echo '```' >> quality_report.md
          cat todo_report.txt >> quality_report.md
          echo '```' >> quality_report.md
        else
          echo "‚úÖ No TODO/FIXME comments found" >> quality_report.md
        fi

    - name: Upload quality report
      uses: actions/upload-artifact@v4
      with:
        name: quality-report
        path: |
          quality_report.md
          fmt_report.txt
          clippy_report.json
          todo_report.txt

  # ‰ª£Á†ÅË¥®ÈáèÊ±áÊÄª
  quality-summary:
    name: Code Quality Summary
    runs-on: ubuntu-latest
    needs: [code-coverage, complexity-analysis, quality-checks]
    if: always()
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: quality_artifacts/

    - name: Generate quality summary
      run: |
        echo "# Code Quality Summary" > quality_summary.md
        echo "Generated at: $(date -u)" >> quality_summary.md
        echo "" >> quality_summary.md
        
        echo "## üìä Quality Metrics" >> quality_summary.md
        echo "| Metric | Status |" >> quality_summary.md
        echo "|--------|--------|" >> quality_summary.md
        echo "| Code Coverage | ${{ needs.code-coverage.result == 'success' && '‚úÖ Completed' || '‚ùå Failed' }} |" >> quality_summary.md
        echo "| Complexity Analysis | ${{ needs.complexity-analysis.result == 'success' && '‚úÖ Completed' || '‚ùå Failed' }} |" >> quality_summary.md
        echo "| Quality Checks | ${{ needs.quality-checks.result == 'success' && '‚úÖ Completed' || '‚ùå Failed' }} |" >> quality_summary.md
        echo "" >> quality_summary.md
        
        echo "## üéØ Quality Score" >> quality_summary.md
        PASSED_CHECKS=0
        TOTAL_CHECKS=3
        
        if [ "${{ needs.code-coverage.result }}" == "success" ]; then
          PASSED_CHECKS=$((PASSED_CHECKS + 1))
        fi
        if [ "${{ needs.complexity-analysis.result }}" == "success" ]; then
          PASSED_CHECKS=$((PASSED_CHECKS + 1))
        fi
        if [ "${{ needs.quality-checks.result }}" == "success" ]; then
          PASSED_CHECKS=$((PASSED_CHECKS + 1))
        fi
        
        QUALITY_SCORE=$((PASSED_CHECKS * 100 / TOTAL_CHECKS))
        echo "**Overall Quality Score**: ${QUALITY_SCORE}% (${PASSED_CHECKS}/${TOTAL_CHECKS} checks passed)" >> quality_summary.md
        echo "" >> quality_summary.md
        
        if [ $QUALITY_SCORE -ge 80 ]; then
          echo "üéâ **Excellent code quality!**" >> quality_summary.md
        elif [ $QUALITY_SCORE -ge 60 ]; then
          echo "üëç **Good code quality with room for improvement**" >> quality_summary.md
        else
          echo "‚ö†Ô∏è **Code quality needs attention**" >> quality_summary.md
        fi
        echo "" >> quality_summary.md
        
        echo "## üìÅ Generated Reports" >> quality_summary.md
        find quality_artifacts/ -name "*.md" | sort | while read file; do
          echo "- \`$(basename "$file")\`" >> quality_summary.md
        done

    - name: Upload quality summary
      uses: actions/upload-artifact@v4
      with:
        name: quality-summary
        path: quality_summary.md

    - name: Comment quality summary on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          try {
            const summary = fs.readFileSync('quality_summary.md', 'utf8');
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## üìä Code Quality Report\n\n${summary}`
            });
          } catch (error) {
            console.log('Could not post quality summary:', error.message);
          }
